'''
길이 n 인 벨트가 두줄

[0][0] : 올리는 위치
[0][n] : 내리는 위치

내리는 위치에 도달하면 즉시 내림
로봇이 벨트 위에서 스스로 이동 가능함
로봇을 올리거나 어떤 칸으로 이동하면 칸의 내구도 1 감소

1. 벨트가 각 칸 위에 있는 로봇과 함께 한 칸 회전한다
 - 회전하기 전 n-1번째 있던 로봇은 내구도 감소 없이 벨트에서 삭제 됨
 
2. 가장 먼저 벨트에 올라간 로봇부터, 벨트가 회전하는 방향으로 이동 가하면 이동
    이동할 수 없다면 가만히 있는다.
    이동 가능 조건 : 이동하려는 칸에 로봇x, 그 칸의 내구도가 1이상 남아있어야 함
3. 올리는 위치 내구도가 0이 아니면 로봇 올림
4. 내구도가 0인 칸의 개수가 k개 이상이면 과정 종료

종료되었을 때 몇 번째 단계가 진행 중이었는지 출력


- i번째 벨트에 로봇이 있어야 한다
- i+1번재 벨트에 로봇이 없으면서 내구도가 1이상이어야 한다
- 위 조건 모두 만족 -> i번째 로봇이 i+1 벨트로 이동 내구도 1 감소
- 이동하게된 벨트가 n번째면 로봇 삭제 
'''
#그냥 구현 문제인듯?

import sys
from collections import deque

n, k = map(int, sys.stdin.readline().split())

belt = deque(list(map(int,sys.stdin.readline().split())))
robot = deque([0]*n)

ans = 0
## 컨베이어 벨트는 2N 만큼 회전하지만, 로봇은 N자리에서 out

#4. 내구도가 0인 칸의 개수가 k개 이상이면 과정 종료
while  1:
    #회전
    belt.rotate(1)
    robot.rotate(1)
    robot[-1] = 0 #1. 이동하게된 벨트가 n번째면 로봇 삭제
  

    if sum(robot): #로봇이 존재하면
        #2. "가장 먼저 벨트에 올라간 로봇"부터
        for i in range(n-2, -1, -1):
            #이동하려는 칸에 로봇x, 그 칸의 내구도가 1이상 남아있어야 함
            if robot[i] == 1 and robot[i+1] == 0 and belt[i+1] >=1 :
                robot[i+1] = 1
                robot[i] = 0
                belt[i+1] -=1
                if belt[i+1] < 0 :
                    belt[i+1] = 0
            robot[-1] = 0 #이동하게된 벨트가 n번째면 로봇 삭제


    #3. 올리는 위치 내구도가 0이 아니면 로봇 올림
    if robot[0] == 0 and belt[0] >=1 :
        robot[0] = 1
        belt[0] -= 1

    ans +=1
    if belt.count(0) >= k:
        break



#종료되었을 때 몇 번째 단계가 진행 중이었는지 출력
print(ans)



